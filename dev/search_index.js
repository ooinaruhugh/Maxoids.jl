var documenterSearchIndex = {"docs":
[{"location":"maxoid-polytope/","page":"Maxoid polytope","title":"Maxoid polytope","text":"Let mathbbRE= mathbbRx_uv  urightarrow v in E be the polynomial ring with variables indexed by the edges of a DAG G. For each pair of nodes i and j in G with at least two paths between them, consider the path polynomial\n\nf_ij = sum_pi in P(ij) prod_u rightarrow v in pix_uv in mathbbRE\n\nEach of the path polynomials f_ij has a associated Newton polytope as the convex hull of the exponent vectors of each term. We call the Minkowski sum of those Newton polytopes (or equivalently, the Newton polytope of the product of the f_ij) the maxoid polytope  of G.\n\nThe maxoid fan arises as the outer normal fan of the maxoid polytope and provides a polyhedral subdivision of the space of weights WinmathbbR^E into types of maxoids.","category":"section"},{"location":"maxoid-polytope/#maxoid_polytope-Tuple{Graph{Directed}}","page":"Maxoid polytope","title":"maxoid_polytope","text":"maxoid_polytope(G::Graph{Directed})\n\nComputes the maxoid polytope for G.\n\n\n\n\n\n","category":"method"},{"location":"maxoid-polytope/#maxoid_fan-Tuple{Graph{Directed}}","page":"Maxoid polytope","title":"maxoid_fan","text":"maxoid_fan(G::Graph{Directed})\n\nComputes the maxoid fan for G as the outer normal fan of the maxoid polytope.\n\n\n\n\n\n","category":"method"},{"location":"implications/#polyhedral_separation_set","page":"Implications and SMT","title":"polyhedral_separation_set","text":"polyhedral_separation_set(G::Graph{Directed}, C::Matrix{RealExpr}, i::Int64, j::Int64, L=Int64[])\n\nComputes a description of the polyhedral set of all matrices C which satisfy the C*-separation [i _||_ j | L] with respect to G.\n\nThe graph G must be transitively closed.\n\n\n\n\n\n","category":"function"},{"location":"implications/#polyhedral_generic_set-Tuple{Graph{Directed}, Matrix{RealExpr}}","page":"Implications and SMT","title":"polyhedral_generic_set","text":"polyhedral_generic_set(G::Graph{Directed}, C::Matrix{RealExpr})\n\nComputes a description of the set of generic weight matrices for G. For these matrices no two distinct paths between any pair of nodes has the same weight.\n\n\n\n\n\n","category":"method"},{"location":"implications/#maxoid_implication-Tuple{Graph{Directed}, Vector{CIStmt}, Vector{CIStmt}}","page":"Implications and SMT","title":"maxoid_implication","text":"maxoid_implication(G::Graph{Directed}, P::Vector{CIStmt}, Q::Vector{CIStmt}; generic_only=false)\n\nTest if every maxoid associated to G satisfies the implication and(P) => or(Q) (the local CI implication problem). If generic_only is true, then only generic maxoids for G are tested.\n\nReturns a tuple consisting of a boolean to indicate if the implication is true, and if it is false, also a counterexample matrix.\n\nThe graph G must be transitively closed.\n\n\n\n\n\n","category":"method"},{"location":"implications/#maxoid_implication-Tuple{Int64, Vector{CIStmt}, Vector{CIStmt}}","page":"Implications and SMT","title":"maxoid_implication","text":"maxoid_implication(n::Int, P::Vector{CIStmt}, Q::Vector{CIStmt}; generic_only=false)\n\nTest if every maxoid on n nodes satisfies the implication and(P) => or(Q) (the global CI implication problem). If generic_only is true, then only those maxoids are tested which are generic for some graph.\n\nReturns a tuple consisting of a boolean to indicate if the implication is true, and if it is false, also a graph and a corresponding counterexample matrix.\n\nThe graph G must be transitively closed.\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#*-separation","page":"Markov properties","title":"*-separation","text":"","category":"section"},{"location":"markov-properties/#C*-separation","page":"Markov properties","title":"C^*-separation","text":"Let (G C) be a weighted DAG with vertex set~V and (L \\subseteq V).  The critical DAG G^ast_CL is the DAG on V such that i to j whenever i and j are  connected via a directed path, and no critical path from i to j in G intersects L.\n\nTwo nodes i and j are C^ast-connected given L if there exists a path from  i to j in G^ast_C L of the following form (Image: C-star separation) where an orange node is called a collider and must belong to L. If no such path exists, then i and j are C^ast-separated given L which is denoted iperp_C^* j mid L.","category":"section"},{"location":"markov-properties/#Maxoids","page":"Markov properties","title":"Maxoids","text":"For a directed graph G on d nodes with weights given by a vector WinmathbbR^E or by a matrix CinmathbbT^dtimes d, we call the collection of C^*-separation statements the maxoid of (GC).\n\nThere is also function to output a maxoid in a compact representation suitable for  processing with a SMT solvers or the likes.\n\nWe also provide functions to list all maxoids arising from a graph or a family of graphs.\n\nThese functions also exist for the same type of output from ci_string.","category":"section"},{"location":"markov-properties/#star_separation-Tuple{Graph{Directed}, Int64, Int64, Vector{Int64}}","page":"Markov properties","title":"star_separation","text":"star_separation(H::Graph{Directed}, i::Vertex, j::Vertex, K::Vector{Vertex})\n\nTests whether node i is star-separated from j in H given the nodes in K and returns an appropriate boolean. \n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#cstar_separation-Tuple{Graph{Directed}, Any, Int64, Int64, Vector{Int64}}","page":"Markov properties","title":"cstar_separation","text":"cstar_separation(G::Graph{Directed}, C, i::Vertex, j::Vertex, K::Vector{Vertex})\n\nTests whether i is C^star-separated from j in G given the nodes in K and weights C on G.\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#cstar_separation-Tuple{Graph{Directed}, AbstractVector{<:RingElement}, Int64, Int64, Vector{Int64}}","page":"Markov properties","title":"cstar_separation","text":"cstar_separation(G::Graph{Directed}, W::AbstractVector{<:RingElement}, i::Vertex, j::Vertex, K::Vector{Vertex})\n\nTests whether i is C^star-separated from j in G given the nodes in K and weights W on G.\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#cstar_separation-Tuple{Graph{Directed}, Int64, Int64, Vector{Int64}}","page":"Markov properties","title":"cstar_separation","text":"cstar_separation(G::Graph{Directed}, i::Vertex, j::Vertex, K::Vector{Vertex})\n\nTests whether i is C^star-separated from j in G given the nodes in K and constant weights on G.\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#maxoid-Tuple{Graph{Directed}, Any}","page":"Markov properties","title":"maxoid","text":"maxoid(G::Graph{Directed}, C)\n\nComputes the maxoid of G given the weights C.\n\nExamples\n\njulia> G = complete_DAG(3)\nDirected graph with 3 nodes and the following edges:\n(1, 2)(1, 3)(2, 3)\n\njulia> C = weights_to_tropical_matrix(G,[0,-1,0])\n[-infty      (0)     (-1)]\n[-infty   -infty      (0)]\n[-infty   -infty   -infty]\n\njulia> maxoid(G,C)\n1-element Vector{CIStmt}:\n [1 _||_ 3 | 2]\n \n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#maxoid-Tuple{Graph{Directed}, Vector{<:RingElement}}","page":"Markov properties","title":"maxoid","text":"maxoid(G::Graph{Directed}, W::Vector{<:RingElement})\n\nComputes the maxoid of G given the weights W.\n\nExamples\n\njulia> G = complete_DAG(3)\nDirected graph with 3 nodes and the following edges:\n(1, 2)(1, 3)(2, 3)\n\njulia> maxoid(G,[0,-1,0])\n1-element Vector{CIStmt}:\n [1 _||_ 3 | 2]\n\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#ci_string-Tuple{Graph{Directed}, Any}","page":"Markov properties","title":"ci_string","text":"ci_string(G::Graph{Directed}, C)\n\nPrints the gaussoids.de-compatible binary string representing the maxoid for G with weights C.\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#all_maxoids-Tuple{Graph{Directed}}","page":"Markov properties","title":"all_maxoids","text":"all_maxoids(G; generic_only = false)\n\nReturns all maxoids that can arise from weights on G. If generic_only is true, then returns only the generic maxoids for G.\n\nExamples\n\njulia> G = graph_from_edges(Directed, [[1,2],[2,3]])\nDirected graph with 3 nodes and the following edges:\n(1, 2)(2, 3)\n\njulia> all_maxoids(G)\n2-element Vector{Vector{CIStmt}}}:\n [[1 _||_ 3 | 2]]\n []\n\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#all_maxoids-Tuple{AbstractVector{Graph{Directed}}}","page":"Markov properties","title":"all_maxoids","text":"all_maxoids(G::AbstractVector{Graph{Directed}}; generic_only = false)\n\nReturns all maxoids that can arise from any graph in G. If generic_only is true, then returns only the generic maxoids.\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#all_maxoids_as_ci_string-Tuple{Graph{Directed}}","page":"Markov properties","title":"all_maxoids_as_ci_string","text":"all_maxoids_as_ci_string(G; generic_only = false)\n\nReturns all maxoids that can arise from weights on G as gaussoids.de-compatible binary string. If generic_only is true, then returns only the generic maxoids for G.\n\n\n\n\n\n","category":"method"},{"location":"markov-properties/#all_maxoids_as_ci_string-Tuple{AbstractVector{Graph{Directed}}}","page":"Markov properties","title":"all_maxoids_as_ci_string","text":"all_maxoids_as_ci_string(G::AbstractVector{Graph{Directed}}; generic_only = false)\n\nReturns all maxoids that can arise from weights on any graph in G as gaussoids.de-compatible binary string. If generic_only is true, then returns only the generic maxoids for G.\n\n\n\n\n\n","category":"method"},{"location":"#Maxoids.jl","page":"Home","title":"Maxoids.jl","text":"Maxoids.jl provides code to work with conditional independence statements of max-linear Bayeisan networks. This package accompanies the paper Polyhedral aspects of maxoids (arxiv).","category":"section"},{"location":"#Setup","page":"Home","title":"Setup","text":"Currently, this package can be installed by executing the following in a Julia REPL.\n\njulia> using Pkg\n\njulia> Pkg.add(\"https://github.com/ooinaruhugh/PolyhedralAspectsofMaxoids\")","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"julia> using Maxoids\n\njulia> G = complete_DAG(4)\n\njulia> maxoids(G,[1,2,3,4,5,6])\n7-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n (3, 1, [2])\n (3, 1, [2, 4])\n (4, 1, [2])\n (4, 1, [3])\n (4, 1, [2, 3])\n (4, 2, [3])\n (4, 2, [1, 3])\n","category":"section"}]
}
